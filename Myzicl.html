import os
import logging
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler
from collections import Counter
from typing import List, Dict
import json
from datetime import datetime

try:
    from music_analyzer import MusicTasteAnalyzer, Track, MoodCategory, Genre
except ImportError:
    from typing import List
    from dataclasses import dataclass
    from enum import Enum

    class MoodCategory(Enum):
        HAPPY = "happy"
        SAD = "sad"
        ENERGETIC = "energetic"
        CALM = "calm"
        NEUTRAL = "neutral"

    class Genre(Enum):
        POP = "pop"
        ROCK = "rock"
        HIP_HOP = "hip-hop"
        ELECTRONIC = "electronic"
        RNB = "r&b"
        INDIE = "indie"
        JAZZ = "jazz"
        CLASSICAL = "classical"
        UNKNOWN = "unknown"

    @dataclass
    class Track:
        name: str
        artist: str
        duration_ms: int
        valence: float
        energy: float
        danceability: float
        acousticness: float = 0.0
        instrumentalness: float = 0.0
        tempo: float = 120.0
        loudness: float = -10.0
        key: int = 0
        mode: int = 1
        genre: str = None

    class MusicTasteAnalyzer:
        def __init__(self, client_id: str = None, client_secret: str = None):
            self.client_id = client_id
            self.client_secret = client_secret

        def get_playlist_tracks(self, playlist_url: str) -> List[Track]:
            return [
                Track("Blinding Lights", "The Weeknd", 200000, 0.8, 0.9, 0.9, 0.1, 0.0, 171, -5.0, 0, 1, "pop"),
                Track("Save Your Tears", "The Weeknd", 215000, 0.6, 0.7, 0.8, 0.2, 0.0, 118, -7.0, 1, 1, "pop"),
                Track("Levitating", "Dua Lipa", 203000, 0.9, 0.8, 0.9, 0.1, 0.0, 103, -4.0, 0, 1, "pop"),
                Track("Good Days", "SZA", 278000, 0.7, 0.5, 0.6, 0.4, 0.1, 120, -8.0, 2, 1, "r&b"),
                Track("Bohemian Rhapsody", "Queen", 354000, 0.4, 0.7, 0.4, 0.3, 0.0, 72, -11.0, 4, 0, "rock"),
            ]

        def analyze_mood_distribution(self, tracks: List[Track]) -> Dict[str, float]:
            return {"happy": 40, "energetic": 30, "calm": 20, "sad": 10}

        def analyze_genre_distribution(self, tracks: List[Track]) -> Dict[str, float]:
            return {"pop": 60, "r&b": 20, "rock": 20}

        def analyze_audio_features(self, tracks: List[Track]) -> Dict[str, float]:
            return {
                "avg_valence": 0.68,
                "avg_energy": 0.74,
                "avg_danceability": 0.72,
                "avg_tempo": 116.8
            }

        def detect_top_artists(self, tracks: List[Track], top_n: int = 5) -> List[Tuple[str, int]]:
            return [("The Weeknd", 2), ("Dua Lipa", 1), ("SZA", 1), ("Queen", 1)]

        def get_taste_summary(self, tracks: List[Track]) -> Dict:
            return {
                "mood": "–í –æ—Å–Ω–æ–≤–Ω–æ–º –ø–æ–∑–∏—Ç–∏–≤–Ω–∞—è –∏ —ç–Ω–µ—Ä–≥–∏—á–Ω–∞—è –º—É–∑—ã–∫–∞",
                "genre": "–ü—Ä–µ–æ–±–ª–∞–¥–∞–µ—Ç –ø–æ–ø-–º—É–∑—ã–∫–∞ —Å —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ R&B",
                "energy": "–í—ã—Å–æ–∫–∞—è —ç–Ω–µ—Ä–≥–µ—Ç–∏–∫–∞",
                "recommendations": ["–ò—Å—Å–ª–µ–¥—É–π—Ç–µ –∏–Ω–¥–∏-–ø–æ–ø", "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π R&B"]
            }

SELECTING_ACTION, ENTER_PLAYLIST, VIEWING_ANALYSIS = range(3)

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class MusicTasteBot:
    def __init__(self, token: str):
        self.token = token
        self.analyzer = MusicTasteAnalyzer(
            client_id=os.getenv('SPOTIFY_CLIENT_ID'),
            client_secret=os.getenv('SPOTIFY_CLIENT_SECRET')
        )
        self.user_data = {}

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–ù–∞—á–∞–ª–æ —Ä–∞–±–æ—Ç—ã —Å –±–æ—Ç–æ–º."""
        user = update.effective_user
        welcome_text = (
            f"–ü—Ä–∏–≤–µ—Ç, {user.first_name}! \n\n"
            "–Ø –ø–æ–º–æ–≥—É –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ç–≤–æ–π –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –≤–∫—É—Å.\n"
            "–ü—Ä–∏—à–ª–∏ –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç (Spotify, Apple Music, –Ø–Ω–¥–µ–∫—Å.–ú—É–∑—ã–∫–∞) "
            "–∏–ª–∏ –≤—ã–±–µ—Ä–∏ –æ–¥–Ω—É –∏–∑ –æ–ø—Ü–∏–π –Ω–∏–∂–µ:"
        )

        keyboard = [
            ["–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç"],
            ["–ú–æ–π –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å"],
            ["–ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏"],
            ["–ü–æ–º–æ—â—å"]
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

        await update.message.reply_text(welcome_text, reply_markup=reply_markup)
        return SELECTING_ACTION

    async def analyze_playlist(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–ó–∞–ø—Ä–æ—Å —Å—Å—ã–ª–∫–∏ –Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç."""
        await update.message.reply_text(
            "–ü—Ä–∏—à–ª–∏ –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–≤–æ–π –ø–ª–µ–π–ª–∏—Å—Ç.\n"
            "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è:\n"
            "‚Ä¢ Spotify\n"
            "‚Ä¢ Apple Music\n"
            "‚Ä¢ –Ø–Ω–¥–µ–∫—Å.–ú—É–∑—ã–∫–∞\n\n"
            "–ò–ª–∏ –Ω–∞–ø–∏—à–∏ /cancel —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å.",
            reply_markup=ReplyKeyboardRemove()
        )
        return ENTER_PLAYLIST

    async def receive_playlist(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª—É—á–µ–Ω–Ω–æ–π —Å—Å—ã–ª–∫–∏ –Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç."""
        playlist_url = update.message.text
        user_id = update.effective_user.id

        processing_msg = await update.message.reply_text("–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –ø–ª–µ–π–ª–∏—Å—Ç...")

        try:
            tracks = self.analyzer.get_playlist_tracks(playlist_url)

            if not tracks:
                await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç—Ä–µ–∫–∏ –∏–∑ –ø–ª–µ–π–ª–∏—Å—Ç–∞.")
                return SELECTING_ACTION

            self.user_data[user_id] = {
                'tracks': tracks,
                'last_analysis': datetime.now().isoformat(),
                'playlist_url': playlist_url
            }

            mood_dist = self.analyzer.analyze_mood_distribution(tracks)
            genre_dist = self.analyzer.analyze_genre_distribution(tracks)
            audio_features = self.analyzer.analyze_audio_features(tracks)
            top_artists = self.analyzer.detect_top_artists(tracks)
            taste_summary = self.analyzer.get_taste_summary(tracks)

            await processing_msg.delete()

            report = self._format_analysis_report(
                mood_dist, genre_dist, audio_features, top_artists, taste_summary
            )

            await update.message.reply_text(report, parse_mode='HTML')

            keyboard = [
                ["–î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"],
                ["–ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏"],
                ["–°—Ä–∞–≤–Ω–∏—Ç—å —Å –¥—Ä—É–∑—å—è–º–∏"],
                ["–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"]
            ]
            reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

            await update.message.reply_text(
                "–ß—Ç–æ —Ö–æ—á–µ—à—å —Å–¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?",
                reply_markup=reply_markup
            )

            return VIEWING_ANALYSIS

        except Exception as e:
            logger.error(f"Error analyzing playlist: {e}")
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥—É—é —Å—Å—ã–ª–∫—É."
            )
            return SELECTING_ACTION

    def _format_analysis_report(self, mood_dist, genre_dist, audio_features, top_artists, taste_summary) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç—á–µ—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞."""
        mood_emojis = {
            "happy": "üòä",
            "sad": "üò¢",
            "energetic": "‚ö°",
            "calm": "üòå",
            "neutral": "üòê"
        }

        mood_text = "\n".join([
            f"{mood_emojis.get(mood)} {mood.capitalize()}: {percent}%"
            for mood, percent in mood_dist.items()
        ])

        genre_text = "\n".join([
            f"{genre.capitalize()}: {percent}%"
            for genre, percent in genre_dist.items()
        ])

        artists_text = "\n".join([
            f"{i+1}. {artist} ({count} —Ç—Ä–µ–∫–æ–≤)"
            for i, (artist, count) in enumerate(top_artists[:5])
        ])

        report = f"""
<b> –ê–ù–ê–õ–ò–ó –ú–£–ó–´–ö–ê–õ–¨–ù–û–ì–û –í–ö–£–°–ê</b>

<b> –û–ë–©–ê–Ø –•–ê–†–ê–ö–¢–ï–†–ò–°–¢–ò–ö–ê:</b>
{taste_summary['mood']}
{taste_summary['genre']}
{taste_summary['energy']}

<b> –†–ê–°–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ù–ê–°–¢–†–û–ï–ù–ò–ô:</b>
{mood_text}

<b> –ü–†–ï–û–ë–õ–ê–î–ê–Æ–©–ò–ï –ñ–ê–ù–†–´:</b>
{genre_text}

<b> –¢–û–ü –ê–†–¢–ò–°–¢–û–í:</b>
{artists_text}

<b> –ê–£–î–ò–û–•–ê–†–ê–ö–¢–ï–†–ò–°–¢–ò–ö–ò:</b>
‚Ä¢ –ü–æ–∑–∏—Ç–∏–≤–Ω–æ—Å—Ç—å: {audio_features['avg_valence']:.0%}
‚Ä¢ –≠–Ω–µ—Ä–≥–∏—á–Ω–æ—Å—Ç—å: {audio_features['avg_energy']:.0%}
‚Ä¢ –¢–∞–Ω—Ü–µ–≤–∞–ª—å–Ω–æ—Å—Ç—å: {audio_features['avg_danceability']:.0%}
‚Ä¢ –¢–µ–º–ø: {audio_features['avg_tempo']:.0f} BPM

<b> –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:</b>
"""
        for rec in taste_summary['recommendations']:
            report += f"‚Ä¢ {rec}\n"

        return report

    async def show_detailed_stats(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É."""
        user_id = update.effective_user.id

        if user_id not in self.user_data or 'tracks' not in self.user_data[user_id]:
            await update.message.reply_text("–°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –ø–ª–µ–π–ª–∏—Å—Ç!")
            return SELECTING_ACTION

        tracks = self.user_data[user_id]['tracks']

        stats_text = "<b> –î–ï–¢–ê–õ–¨–ù–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê</b>\n\n"

        total_tracks = len(tracks)
        avg_duration = sum(t.duration_ms for t in tracks) / total_tracks / 60000
        stats_text += f"<b>–û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</b>\n"
        stats_text += f"‚Ä¢ –í—Å–µ–≥–æ —Ç—Ä–µ–∫–æ–≤: {total_tracks}\n"
        stats_text += f"‚Ä¢ –°—Ä–µ–¥–Ω—è—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {avg_duration:.1f} –º–∏–Ω\n"

        keys = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
        key_counter = Counter(t.key for t in tracks)
        if key_counter:
            most_common_key = key_counter.most_common(1)[0]
            stats_text += f"‚Ä¢ –õ—é–±–∏–º—ã–π –∫–ª—é—á: {keys[most_common_key[0]]}\n"

        major_count = sum(1 for t in tracks if t.mode == 1)
        minor_count = total_tracks - major_count
        stats_text += f"‚Ä¢ –ú–∞–∂–æ—Ä/–ú–∏–Ω–æ—Ä: {major_count}/{minor_count} —Ç—Ä–µ–∫–æ–≤\n\n"

        await update.message.reply_text(stats_text, parse_mode='HTML')
        return VIEWING_ANALYSIS

    async def get_recommendations(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏."""
        user_id = update.effective_user.id

        if user_id not in self.user_data:
            await update.message.reply_text(
                "–°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Å–≤–æ–π –ø–ª–µ–π–ª–∏—Å—Ç, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏!"
            )
            return SELECTING_ACTION

        recommendations = [
            "<b>–û—Ç–∫—Ä—ã—Ç–∏–µ –Ω–µ–¥–µ–ª–∏:</b> –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∞–ª—å–±–æ–º 'The Slow Rush' –æ—Ç Tame Impala",
            "<b>–ü–æ—Ö–æ–∂–∏–µ –∞—Ä—Ç–∏—Å—Ç—ã:</b> –ï—Å–ª–∏ –≤–∞–º –Ω—Ä–∞–≤–∏—Ç—Å—è The Weeknd, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ Brent Faiyaz",
            "<b>–ö–ª–∞—Å—Å–∏–∫–∞ –∂–∞–Ω—Ä–∞:</b> –ò—Å—Å–ª–µ–¥—É–π—Ç–µ —Ä–∞–Ω–Ω–∏–µ —Ä–∞–±–æ—Ç—ã Daft Punk",
            "<b>–ù–æ–≤–∏–Ω–∫–∏ –≤ –≤–∞—à–µ–º —Å—Ç–∏–ª–µ:</b> –û–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å –Ω–æ–≤—ã–º –∞–ª—å–±–æ–º–æ–º SZA",
            "<b>–ú–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–π –≤–∑–≥–ª—è–¥:</b> –ü–æ—Å–ª—É—à–∞–π—Ç–µ K-pop –≥—Ä—É–ø–ø—ã –∫–∞–∫ BTS –∏–ª–∏ Blackpink",
            "<b>–°–º–µ—à–µ–Ω–∏–µ –∂–∞–Ω—Ä–æ–≤:</b> –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Ñ—å—é–∂–Ω –¥–∂–∞–∑ –∏ —ç–ª–µ–∫—Ç—Ä–æ–Ω–∏–∫–∏"
        ]

        rec_text = "<b> –ü–ï–†–°–û–ù–ê–õ–ò–ó–ò–†–û–í–ê–ù–ù–´–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò</b>\n\n"
        for rec in recommendations[:4]:
            rec_text += f"‚Ä¢ {rec}\n"

        rec_text += "\n<b> –°–æ–≤–µ—Ç:</b> –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–ª—É—à–∞—Ç—å –º—É–∑—ã–∫—É –≤ —Ä–∞–∑–Ω–æ–µ –≤—Ä–µ–º—è —Å—É—Ç–æ–∫ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π!"

        await update.message.reply_text(rec_text, parse_mode='HTML')
        return VIEWING_ANALYSIS

    async def show_profile(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–ü–æ–∫–∞–∑–∞—Ç—å –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        user_id = update.effective_user.id

        if user_id not in self.user_data:
            profile_text = (
                "<b> –¢–í–û–ô –ú–£–ó–´–ö–ê–õ–¨–ù–´–ô –ü–†–û–§–ò–õ–¨</b>\n\n"
                "–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤.\n"
                "–ü—Ä–∏—à–ª–∏ –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç, —á—Ç–æ–±—ã —è –º–æ–≥ —Å–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–≤–æ–π –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –ø–æ—Ä—Ç—Ä–µ—Ç!"
            )
        else:
            tracks = self.user_data[user_id]['tracks']
            mood_dist = self.analyzer.analyze_mood_distribution(tracks)
            top_mood = max(mood_dist.items(), key=lambda x: x[1])

            mood_titles = {
                "happy": "–û–ø—Ç–∏–º–∏—Å—Ç",
                "energetic": "–≠–Ω–µ—Ä–¥–∂–∞–π–∑–µ—Ä",
                "calm": "–°–æ–∑–µ—Ä—Ü–∞—Ç–µ–ª—å",
                "sad": "–ú–µ–ª–∞–Ω—Ö–æ–ª–∏–∫",
                "neutral": "–£–Ω–∏–≤–µ—Ä—Å–∞–ª"
            }

            profile_text = (
                f"<b>–¢–í–û–ô –ú–£–ó–´–ö–ê–õ–¨–ù–´–ô –ü–†–û–§–ò–õ–¨</b>\n\n"
                f"<b>–¢–∏–ø —Å–ª—É—à–∞—Ç–µ–ª—è:</b> {mood_titles.get(top_mood[0], '–£–Ω–∏–≤–µ—Ä—Å–∞–ª')}\n"
                f"<b>–ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ —Ç—Ä–µ–∫–æ–≤:</b> {len(tracks)}\n"
                f"<b>–ü–æ—Å–ª–µ–¥–Ω–∏–π –∞–Ω–∞–ª–∏–∑:</b> {self.user_data[user_id]['last_analysis'][:10]}\n\n"
                f"<b>–¢–≤–æ—è –≥–ª–∞–≤–Ω–∞—è –º—É–∑—ã–∫–∞–ª—å–Ω–∞—è —á–µ—Ä—Ç–∞:</b>\n"
            )

            if top_mood[0] == "happy":
                profile_text += "–¢—ã –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—à—å –ø–æ–∑–∏—Ç–∏–≤–Ω—É—é –∏ uplifting –º—É–∑—ã–∫—É!"
            elif top_mood[0] == "energetic":
                profile_text += "–¢—ã –ª—é–±–∏—à—å —ç–Ω–µ—Ä–≥–∏—á–Ω—É—é –º—É–∑—ã–∫—É –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –∏ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏!"
            elif top_mood[0] == "calm":
                profile_text += "–¢–µ–±–µ –Ω—Ä–∞–≤–∏—Ç—Å—è —Å–ø–æ–∫–æ–π–Ω–∞—è, –º–µ–¥–∏—Ç–∞—Ç–∏–≤–Ω–∞—è –º—É–∑—ã–∫–∞!"
            elif top_mood[0] == "sad":
                profile_text += "–¢—ã —Ü–µ–Ω–∏—à—å –≥–ª—É–±–æ–∫—É—é, —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—É—é –º—É–∑—ã–∫—É!"
            else:
                profile_text += "–£ —Ç–µ–±—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã–π –∏ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –≤–∫—É—Å!"

        await update.message.reply_text(profile_text, parse_mode='HTML')
        return SELECTING_ACTION

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É."""
        help_text = """
<b>–ü–û–ú–û–©–¨ –ü–û –ö–û–ú–ê–ù–î–ê–ú</b>

<b>–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>
‚Ä¢ /start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º
‚Ä¢ /analyze - –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç
‚Ä¢ /profile - –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å
‚Ä¢ /recommendations - –ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
‚Ä¢ /help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É
‚Ä¢ /cancel - –û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ

<b>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:</b>
1. –ù–∞–∂–º–∏ "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç"
2. –ü—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ —Å–≤–æ–π –ø–ª–µ–π–ª–∏—Å—Ç
3. –ü–æ–ª—É—á–∏ –¥–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å–≤–æ–µ–≥–æ –≤–∫—É—Å–∞
4. –ò—Å–ø–æ–ª—å–∑—É–π —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –Ω–æ–≤–æ–π –º—É–∑—ã–∫–∏

<b>–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã:</b>
‚Ä¢ Spotify
‚Ä¢ Apple Music
‚Ä¢ –Ø–Ω–¥–µ–∫—Å.–ú—É–∑—ã–∫–∞

<b>–ß—Ç–æ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º:</b>
–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –º—É–∑—ã–∫–∏
–ñ–∞–Ω—Ä–æ–≤—ã–µ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è
–õ—é–±–∏–º—ã—Ö –∞—Ä—Ç–∏—Å—Ç–æ–≤
–ê—É–¥–∏–æ—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
        """
        await update.message.reply_text(help_text, parse_mode='HTML')
        return SELECTING_ACTION

    async def cancel(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–û—Ç–º–µ–Ω–∞ —Ç–µ–∫—É—â–µ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è."""
        await update.message.reply_text(
            "–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.",
            reply_markup=ReplyKeyboardMarkup([["–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç"]], resize_keyboard=True)
        )
        return ConversationHandler.END

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π."""
        text = update.message.text.lower()

        if text == "–ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç":
            return await self.analyze_playlist(update, context)
        elif text == "–º–æ–π –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å":
            return await self.show_profile(update, context)
        elif text == "–ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏":
            return await self.get_recommendations(update, context)
        elif text == "–ø–æ–º–æ—â—å":
            return await self.help_command(update, context)
        elif text == "–¥–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞":
            return await self.show_detailed_stats(update, context)
        elif text == "—Å—Ä–∞–≤–Ω–∏—Ç—å —Å –¥—Ä—É–∑—å—è–º–∏":
            await update.message.reply_text(
                "–§—É–Ω–∫—Ü–∏—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å–∫–æ—Ä–æ –ø–æ—è–≤–∏—Ç—Å—è!\n"
                "–ê –ø–æ–∫–∞ –ø–æ–¥–µ–ª–∏—Å—å —Å–≤–æ–∏–º –∞–Ω–∞–ª–∏–∑–æ–º —Å –¥—Ä—É–∑—å—è–º–∏."
            )
            return VIEWING_ANALYSIS
        elif text == "–≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é":
            keyboard = [
                ["–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç"],
                ["–ú–æ–π –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å"],
                ["–ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏"],
                ["–ü–æ–º–æ—â—å"]
            ]
            reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
            await update.message.reply_text(
                "–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
                reply_markup=reply_markup
            )
            return SELECTING_ACTION
        else:
            if "http" in text or "spotify" in text or "music.yandex" in text:
                return await self.receive_playlist(update, context)
            else:
                await update.message.reply_text(
                    "–Ø –Ω–µ –ø–æ–Ω—è–ª –∫–æ–º–∞–Ω–¥—É. –ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –∏–ª–∏ /help –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏."
                )
                return SELECTING_ACTION

def main():
    """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞."""
    TELEGRAM_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')

    if not TELEGRAM_TOKEN:
        raise ValueError("–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å TELEGRAM_BOT_TOKEN –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")

    bot = MusicTasteBot(TELEGRAM_TOKEN)
    
    application = Application.builder().token(TELEGRAM_TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', bot.start)],
        states={
            SELECTING_ACTION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_message)
            ],
            ENTER_PLAYLIST: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, bot.receive_playlist)
            ],
            VIEWING_ANALYSIS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_message)
            ],
        },
        fallbacks=[CommandHandler('cancel', bot.cancel)],
        allow_reentry=True
    )

    application.add_handler(CommandHandler("help", bot.help_command))
    application.add_handler(CommandHandler("profile", bot.show_profile))
    application.add_handler(CommandHandler("recommendations", bot.get_recommendations))
    application.add_handler(CommandHandler("analyze", bot.analyze_playlist))

    application.add_handler(conv_handler)

    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
